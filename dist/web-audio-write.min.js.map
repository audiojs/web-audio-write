{
  "version": 3,
  "sources": ["../node_modules/audioworklet-polyfill/src/index.js", "../node_modules/audioworklet-polyfill/src/realm.js", "../index.js"],
  "sourcesContent": ["/**\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\nimport { Realm } from './realm';\n\nconst PARAMS = [];\nlet nextPort;\n\nif (typeof AudioWorkletNode !== 'function') {\n  self.AudioWorkletNode = function AudioWorkletNode (context, name, options) {\n    const processor = getProcessorsForContext(context)[name];\n    const outputChannels = options && options.outputChannelCount ? options.outputChannelCount[0] : 2;\n    const scriptProcessor = context.createScriptProcessor(undefined, 2, outputChannels);\n\n    scriptProcessor.parameters = new Map();\n    if (processor.properties) {\n      for (let i = 0; i < processor.properties.length; i++) {\n        const prop = processor.properties[i];\n        const node = context.createGain().gain;\n        node.value = prop.defaultValue;\n        // @TODO there's no good way to construct the proxy AudioParam here\n        scriptProcessor.parameters.set(prop.name, node);\n      }\n    }\n\n    const mc = new MessageChannel();\n    nextPort = mc.port2;\n    const inst = new processor.Processor(options || {});\n    nextPort = null;\n\n    scriptProcessor.port = mc.port1;\n    scriptProcessor.processor = processor;\n    scriptProcessor.instance = inst;\n    scriptProcessor.onaudioprocess = onAudioProcess;\n    return scriptProcessor;\n  };\n\n  Object.defineProperty((self.AudioContext || self.webkitAudioContext).prototype, 'audioWorklet', {\n    get () {\n      return this.$$audioWorklet || (this.$$audioWorklet = new self.AudioWorklet(this));\n    }\n  });\n\n  self.AudioWorklet = class AudioWorklet {\n    constructor (audioContext) {\n      this.$$context = audioContext;\n    }\n\n    addModule (url, options) {\n      return fetch(url).then(r => {\n        if (!r.ok) throw Error(r.status);\n        return r.text();\n      }).then(code => {\n        const context = {\n          sampleRate: 0,\n          currentTime: 0,\n          AudioWorkletProcessor () {\n            this.port = nextPort;\n          },\n          registerProcessor: (name, Processor) => {\n            const processors = getProcessorsForContext(this.$$context);\n            processors[name] = {\n              realm,\n              context,\n              Processor,\n              properties: Processor.parameterDescriptors || []\n            };\n          }\n        };\n        context.self = context;\n        const realm = new Realm(context, document.documentElement);\n        realm.exec(((options && options.transpile) || String)(code));\n        return null;\n      });\n    }\n  };\n}\n\nfunction onAudioProcess (e) {\n  const parameters = {};\n  let index = -1;\n  this.parameters.forEach((value, key) => {\n    const arr = PARAMS[++index] || (PARAMS[index] = new Float32Array(this.bufferSize));\n    // @TODO proper values here if possible\n    arr.fill(value.value);\n    parameters[key] = arr;\n  });\n  this.processor.realm.exec(\n    'self.sampleRate=sampleRate=' + this.context.sampleRate + ';' +\n    'self.currentTime=currentTime=' + this.context.currentTime\n  );\n  const inputs = channelToArray(e.inputBuffer);\n  const outputs = channelToArray(e.outputBuffer);\n  this.instance.process([inputs], [outputs], parameters);\n\n  // @todo - keepalive\n  // let ret = this.instance.process([inputs], [outputs], parameters);\n  // if (ret === true) { }\n}\n\nfunction channelToArray (ch) {\n  const out = [];\n  for (let i = 0; i < ch.numberOfChannels; i++) {\n    out[i] = ch.getChannelData(i);\n  }\n  return out;\n}\n\nfunction getProcessorsForContext (audioContext) {\n  return audioContext.$$processors || (audioContext.$$processors = {});\n}\n", "/**\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\nexport function Realm (scope, parentElement) {\n  const frame = document.createElement('iframe');\n  frame.style.cssText = 'position:absolute;left:0;top:-999px;width:1px;height:1px;';\n  parentElement.appendChild(frame);\n  const win = frame.contentWindow;\n  const doc = win.document;\n  let vars = 'var window,$hook';\n  for (const i in win) {\n    if (!(i in scope) && i !== 'eval') {\n      vars += ',';\n      vars += i;\n    }\n  }\n  for (const i in scope) {\n    vars += ',';\n    vars += i;\n    vars += '=self.';\n    vars += i;\n  }\n  const script = doc.createElement('script');\n  script.appendChild(doc.createTextNode(\n    `function $hook(self,console) {\"use strict\";\n        ${vars};return function() {return eval(arguments[0])}}`\n  ));\n  doc.body.appendChild(script);\n  this.exec = win.$hook(scope, console);\n}\n", "import 'audioworklet-polyfill'\r\n\r\n// FIXME: move worklet into a separate file\r\nconst workletURL = URL.createObjectURL(new Blob([`\r\n  registerProcessor('writer-worklet', class extends AudioWorkletProcessor {\r\n    constructor() {\r\n      super()\r\n      this.q = []\r\n      this.end = false\r\n      this.cur = null\r\n      this.port.onmessage = e => e.data === null ? this.end = true : this.q.push(e.data)\r\n    }\r\n    process([input], [output]) {\r\n      let channels = output.length, remains = output[0].length\r\n      while (remains > 0) {\r\n        if (!this.cur) {\r\n          if (this.cur = this.q.shift()) this.port.postMessage(this.cur[0].length)\r\n          else {\r\n            if (this.end) {this.port.postMessage(null);return false}\r\n            this.port.postMessage(0)\r\n            break\r\n          }\r\n        }\r\n        if (this.cur[0].length > remains) {\r\n          for (let c = 0; c < channels; c++) {\r\n            output[c].set(this.cur[c].subarray(0, remains), output[c].length - remains)\r\n            this.cur[c] = this.cur[c].subarray(remains)\r\n          }\r\n          remains = 0\r\n        }\r\n        else {\r\n          for (let c = 0; c < channels; c++) output[c].set(this.cur[c], output[c].length - remains)\r\n          remains -= this.cur[0].length\r\n          this.cur = null\r\n        }\r\n      }\r\n      return true\r\n    }\r\n  })\r\n`], { type: 'text/javascript' }));\r\n\r\n// to be sync-api compatible, it creates worklet lazily\r\nexport default function createWriter (dest) {\r\n  if (!dest) dest = (new AudioContext).destination\r\n  const context = dest.context\r\n\r\n  let listeners\r\n\r\n  let init = context.audioWorklet.addModule(workletURL).then(() => {\r\n    init = null\r\n\r\n    write.node = new AudioWorkletNode(context, 'writer-worklet', {\r\n      outputChannelCount: [dest.channelCount]\r\n    })\r\n    listeners = []\r\n    write.node.port.onmessage = e => {\r\n      listeners.shift()(e)\r\n      if (e.data === null) write.node.closed = true\r\n    }\r\n    write.node.connect(dest)\r\n    write.node.write = write\r\n  })\r\n\r\n  // to make API sync, first consuming awaits for init\r\n  function write (data) {\r\n    if (write.then) write.then = null\r\n    return init ? init.then(() => push(data)) : push(data)\r\n  }\r\n  write.then = (fn) => {\r\n    write.then = null\r\n    init.then(() => fn(write))\r\n  }\r\n\r\n  function push(data) {\r\n    if (write.node.closed) throw Error('Writer is closed')\r\n\r\n    let arr = data\r\n    if (data) {\r\n      if (data.getChannelData) {\r\n        arr = []\r\n        for (let c = 0; c < dest.channelCount; c++) {\r\n          arr[c] = c < data.numberOfChannels ? data.getChannelData(c) : new Float32Array()\r\n        }\r\n      }\r\n      else if (typeof data[0] === 'number') {\r\n        arr = []\r\n        let len = Math.floor(data.length / dest.channelCount)\r\n        for (let c = 0; c < dest.channelCount; c++) {\r\n          arr[c] = data.subarray ? data.subarray(c * len, c * len + len) : new Float32Array(data.slice(c * len, c * len + len))\r\n        }\r\n      }\r\n    }\r\n\r\n    return new Promise(resolve => {\r\n      listeners.push(resolve)\r\n      write.node.port.postMessage(arr)\r\n    })\r\n  }\r\n\r\n  return write\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
